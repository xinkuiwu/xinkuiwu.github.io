<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>前端框架Vue自学之Vuex（八） | 伍新奎的博客空间</title><meta name="author" content="伍新奎"><meta name="copyright" content="伍新奎"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="终极目标：掌握和使用Vue（全家桶：Core+Vue-router+Vuex） 本博客目的：记录Vue学习的进度和心得（Vuex，终于到Vuex了，泪目） 内容：学习和使用Vuex。">
<meta property="og:type" content="article">
<meta property="og:title" content="前端框架Vue自学之Vuex（八）">
<meta property="og:url" content="http://example.com/2019/12/29/blog36/index.html">
<meta property="og:site_name" content="伍新奎的博客空间">
<meta property="og:description" content="终极目标：掌握和使用Vue（全家桶：Core+Vue-router+Vuex） 本博客目的：记录Vue学习的进度和心得（Vuex，终于到Vuex了，泪目） 内容：学习和使用Vuex。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/blog_wxk.jpg">
<meta property="article:published_time" content="2019-12-29T08:03:28.000Z">
<meta property="article:modified_time" content="2020-01-02T08:36:02.980Z">
<meta property="article:author" content="伍新奎">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="框架">
<meta property="article:tag" content="vue">
<meta property="article:tag" content="Vuex">
<meta property="article:tag" content="Vuex配置">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/blog_wxk.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2019/12/29/blog36/index.html"><link rel="preconnect" href="https://lib.baomitu.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lib.baomitu.com/font-awesome/6.4.2/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://lib.baomitu.com/fancyapps-ui/5.0.24/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://lib.baomitu.com/egjs-infinitegrid/4.10.1/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '前端框架Vue自学之Vuex（八）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-01-02 16:36:02'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/blog_wxk.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">96</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">150</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">68</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="伍新奎的博客空间"><span class="site-name">伍新奎的博客空间</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">前端框架Vue自学之Vuex（八）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">Created</span><time datetime="2019-12-29T08:03:28.000Z" title="Created 2019-12-29 16:03:28">2019-12-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/vue/">vue</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/vue/vuex/">vuex</a></span></div><div class="meta-secondline"></div></div></div><article class="post-content" id="article-container"><p>终极目标：掌握和使用Vue（全家桶：Core+Vue-router+Vuex）</p>
<p>本博客目的：记录Vue学习的进度和心得（Vuex，终于到Vuex了，泪目）</p>
<p>内容：学习和使用Vuex。</p>
<span id="more"></span>

<p>正文：</p>
<h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><h3 id="一、Vuex概念和作用解析"><a href="#一、Vuex概念和作用解析" class="headerlink" title="一、Vuex概念和作用解析"></a>一、Vuex概念和作用解析</h3><p>　　1、认识Vuex</p>
<p>　　Vuex是一个专为vue.js应用程序开发的<strong>状态管理模式</strong>。</p>
<p>　　它采用<strong>集中式存储管理</strong>应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex也集成到Vue的官方调试工具，提供了诸如零配置的time-travel调试、状态快照导入导出等高级调试功能。Vuex也是响应式的。</p>
<p>　　2、状态管理</p>
<p>　　我们可以简单地将状态管理看成把需要多个组件共享的变量（状态）全部存储在一个对象里，然后，将这个对象放在顶层的Vue实例中，让其他组件可以使用。</p>
<p> 　看上去我们可以直接修改Vue的原型实现共享变量（自己封装也很麻烦），但其不是响应式的。而Vuex就是为了提供一个在多个组件间共享状态的插件并且还是响应式的。</p>
<p>　　3、管理什么状态</p>
<p>　　有什么状态是需要我们在多个组件间共享的呢？</p>
<p>　　如果我们做过大型开发，一定遇到过多个状态，在<strong>多个界面间的共享问题</strong>。比如用户的登录状态、用户名称、头像、地理位置信息等等。比如商品的收藏、购物车的物品等等。这些状态信息，我们都可以放在统一的地方，对它进行保存和管理（用Vuex），而且它们还是响应式的。</p>
<h3 id="二、单界面到多界面状态管理切换"><a href="#二、单界面到多界面状态管理切换" class="headerlink" title="二、单界面到多界面状态管理切换"></a>二、单界面到多界面状态管理切换</h3><p>　　1、单界面的状态管理</p>
<p>　　<img src="/2019/12/29/blog36/1803687-20191230084458159-1831636706-1577951944336.png" alt="img"></p>
<p> 　state储存当前界面（组件）的状态（姑且看成在vue实例中的data中的属性），这个状态是在view（视图层）中显示，当发生一些行为actions时，会修改状态，这个状态也是通过view显示。使用Vue就可以做到单界面的状态管理。</p>
<p>　　2、多界面状态管理</p>
<p>　　当我们不想只在一个界面进行状态管理，即想多界面状态管理。也就是说对于某些状态（状态1,2,3）来说只属于我们某一个视图，但是也有一些状态（a,b,c）属于多个视图共同想要维护的。通常，状态1,2,3放在自己的房间里，自己管理自己；但是状态a,b,c，我们希望交给一个大管家来统一帮助我们管理，而Vuex就是为我们提供这个大管家的工具。</p>
<p>　　<strong>全局单例模式</strong>（大管家）。我们现在要做的就是将共享的状态抽取出来，交给我们的大管家，统一进行管理。之后，我们每个视图，按照我们<strong>规定好的</strong>规定，进行访问和修改等操作。这就是Vuex背后的基本思想。（单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。）</p>
<p>　　首先，安装。Vuex是个插件，先安装，npm install vuex –save（运行时依赖）。</p>
<p>　　接着，创建Vuex的文件夹（src下）。通常我们会把使用Vuex的代码放置在一个文件夹内进行管理（类似使用vue-router我们会创建一个router文件夹），所以我们创建一个名为store的文件夹（通常起store仓库，而不是vuex）。</p>
<p>　　然后在store文件夹下，创建index.js。导入Vue和Vuex，安装插件（Vue.use（插件）），创建Vuex.store对象（放置state，mutation，actions，getters,modules），接着导出store。然后在main.js中使用，挂载。</p>
<p>　　<img src="/2019/12/29/blog36/1803687-20191230090706459-2043570552-1577951968377.png" alt="img"></p>
<p> 　<img src="/2019/12/29/blog36/1803687-20191230090451862-550869321-1577951971673.png" alt="img"> </p>
<p>　　 Vuex.store对象中，state就是放置共享的状态（可以简单先看成变量）。由于store已经挂载在vue实例上，也就是所有的组件都可以使用和这个状态，通过$store来调用这个index.js中的store，即Vuex.store实例对象。然后通过$store.state.X属性来获取state中的X属性。</p>
<p><img src="/2019/12/29/blog36/1803687-20191230092215533-807456798-1577951974091.png" alt="img"></p>
<p> 　官方的图。可以发现组件不是直接地获取和修改state对象的，是有一定流程的。devtools是Vue开发的一个浏览器插件，可以帮我们记录跟踪每次修改state的记录。<strong>注意</strong>，组件可以直接操作到mutations，但一定是得是同步操作（因为devtools也是同步的），而如果是异步操作，就必须经过actions的流程。而异步操作通常是网络请求，所以actions和后端backend API是可以结合使用的。</p>
<p>　　3、devtools和mutations</p>
<p>　　devtools是vue开发的一个浏览器插件。假设我们使用Chrome浏览器，打开Chrome网上应用，搜索devtools。</p>
<p><img src="/2019/12/29/blog36/1803687-20191230095505362-408305347-1577951976986.png" alt="img"></p>
<p> 　点击添加，当我们重新打开Chrome浏览器，打开控制台，选项多个vue，说明安装成功。</p>
<p>　　<img src="/2019/12/29/blog36/1803687-20191230095816527-437167304-1577951344687.png" alt="img"></p>
<p> 　这个devtools插件就是用来调试vue程序的（包括Vuex）。点击第二个按钮，就是专门调试Vuex的界面，例如我之前在index.js代码中添加了state的一个属性count，浏览器也显示出来了。此外，如果我们是通过mutations修改的状态，也是可以在这里面进行跟踪。这也是官网推荐我们不要在组件中直接修改state的原因之一。</p>
<p>　　<img src="/2019/12/29/blog36/1803687-20191230101729025-222781669-1577951325354.png" alt="img"></p>
<p> 　mutations中，通常定义一些方法，而这些方法的默认参数就是state对象，所以操作state对象的一些属性非常容易。</p>
<p>　　<img src="/2019/12/29/blog36/1803687-20191230101702200-1134948414-1577951338382.png" alt="img">（mutations里面定义方法）</p>
<p> 　然后假如在App.vue调用这个方法，（首先监听事件等），然后在methods中定义方法，使用这个mutation的方法，但注意得使用**.commit(‘方法名’)**，而不是直接.方法名。</p>
<p>　　<img src="/2019/12/29/blog36/1803687-20191230102439432-1998894975-1577951998731.png" alt="img"></p>
<p> 　然后用devtools查看，发现的确可以追踪状态的改变。并且选择某次的修改（从右边的记录栏里），可以查看当时的state情况。</p>
<p><img src="/2019/12/29/blog36/1803687-20191230102427385-1521935516-1577951333885.png" alt="img"></p>
<h3 id="三、Vuex核心"><a href="#三、Vuex核心" class="headerlink" title="三、Vuex核心"></a>三、Vuex核心</h3><p>　　Vuex核心概念：<strong>State，Getters，Mutation，Action，Module</strong>。State保存状态相关的信息，Getters优点类似组件的计算属性，Mutation通常定义一些操作状态的方法，Action主要做些异步操作，Module用于划分模块，针对不同模型，进行一些保存等操作。</p>
<p>　　1、state单一状态树的理解</p>
<p>　　<strong>state单一状态树（Single Source of Truth，单一数据源）</strong>。</p>
<p>　　例如，在我们国内有很多信息需要被记录，例如上学时的个人档案，工作后的社保记录等，这些信息被分散在很多地方进行管理，有一个你需要办某个业务时（比如入户某个城市），你会发现你需要到各个对应的地方获取（打印）各种资料信息，最后到一个地方提交证明你的信息无误。（这样做的好处是管理责任划分明显，安全性高。）这种保存信息的方案，低效又不方便管理，以及日后的维护也是一个庞大的工作。</p>
<p>　　这个和我们在应用开发中比较类似，如果你的状态信息是保存到多个Store对象中，那么之后的管理和维护等等都会变得特别困难，所以<strong>Vuex也使用了单一状态树来管理应用层级的全部状态</strong>。单一状态树能够让我们最直接的方法找到某个状态的片段，而且在之后的维护和调试过程中，也可以非常方便的管理和维护。</p>
<p>　　2、getters基本使用</p>
<p>　　有时候，我们需要从store中获取一些state变异后的状态，然后使用这个变异（就是做某些操作）的状态。</p>
<p>　　例如基于之前counter例子，使用getters，操作counter变为平方后的值。</p>
<p>　　同样地，getters内的方法也是有默认参数state。</p>
<p>　　<img src="/2019/12/29/blog36/1803687-20191230105307279-908642179-1577951349722.png" alt="img"></p>
<p>　　然后通过$store.getters.方法名调用。</p>
<p>　　<img src="/2019/12/29/blog36/1803687-20191230105622307-313305349-1577951351428.png" alt="img"></p>
<p> 　最后在页面也显示了正确的结果。</p>
<p>　　<img src="/2019/12/29/blog36/1803687-20191230105546832-1837264897-1577951354391.png" alt="img"></p>
<p> 　总结：getters里面定义的方法是针对state的，虽然它在单个界面使用的时候，非常类似于计算属性。但是如果在多个界面使用时，getters的方法是比计算属性好得多，因为不需要在每个界面都定义和使用计算属性那么麻烦。（这更体现了公共管理state的思想，妙啊）</p>
<p>　　此外，getters定义的方法定义中，除了可以传入state，也可以传入getters本身（将其作为方法中的参数）。</p>
<p><img src="/2019/12/29/blog36/1803687-20191230142018573-1402162140-1577951357828.png" alt="img"></p>
<p> 　　假如我们需要带参数的getters方法，即可以返回一个函数，让这个函数带参数。注意，不能直接想之前一样简单的把参数放入getters方法函数中（因为其本身就有默认参数，放进去也是只是代替默认参数的名称而已，里面调用的还是默认参数，如state,getters等），这样不起作用。　　</p>
<p>　　<img src="/2019/12/29/blog36/1803687-20191230142409263-620306451-1577951360416.png" alt="img"> </p>
<p> <img src="/2019/12/29/blog36/1803687-20191230142517043-1874995329-1577952007938.png" alt="img"></p>
<p> 　当然也可以写成箭头函数的形式：</p>
<p><img src="/2019/12/29/blog36/1803687-20191230142801723-915191364-1577951365628.png" alt="img"></p>
<p>　　3、mutations的携带参数</p>
<p>　　Vuex的store状态的更新唯一方式：<strong>提交Mutation</strong>。（$store.commit()方法）</p>
<p>　　Mutation主要包括两部分：<strong>字符串的事件类型（type）</strong>和<strong>一个回调函数（handler）</strong>，该回调函数的第一个参数就是state。例如之前我们的举例中，increment是事件类型，具体的处理就是回调函数。（后一节有说这种格式的提交风格）</p>
<p>　　在通过mutation更新数据的时候，有可能我们希望携带一些<strong>额外的参数</strong>。参数被称为是mutation的<strong>载荷</strong>（<strong>payload</strong>）。</p>
<p>　　mutations可以携带参数，在commit后面附上变量即可，然后在mutation对应的方法里面使用这个参数即可。例如只提交一个参数（变量，对象都行）：（当传入多个变量时，可以写成一个对象）</p>
<p><img src="/2019/12/29/blog36/1803687-20191230143711129-180359759-1577951371510.png" alt="img"></p>
<p> 　<img src="/2019/12/29/blog36/1803687-20191230143815498-714701509-1577951373863.png" alt="img"></p>
<p>　　4、Mutation的提交风格</p>
<p>　　上一小节，是通过commit进行提交时一种普通的方式。</p>
<p>　　Vue还提供了另外一种风格，它是一个包含type属性的对象。此时，后面是一个payload对象，即下例中的count是一个对象。（此时代码写的就和之前不一样）<img src="/2019/12/29/blog36/1803687-20191230144927568-583148471-1577951377808.png" alt="img"></p>
<p> 　<img src="/2019/12/29/blog36/1803687-20191230144744011-621923655-1577951381918.png" alt="img">（直接引用count是一个payload对象，调用值的话，写成count.count才合理（前一个count是形参，后者的count指的是原来的count值））</p>
<p> 　所以应该写成这样比较合理：</p>
<p>　　　<img src="/2019/12/29/blog36/1803687-20191230145026814-706313984-1577951384095.png" alt="img"></p>
<p>　　5、Mutation响应规则（数据的<strong>响应式</strong>原理）</p>
<p>　　　Vuex的store中的state是响应式的（源码中是通过Dep，Dep是data每个对象包括子对象都拥有一个该对象, 当所绑定的数据有变更时, 通过dep.notify()通知Watcher），当state中的数据发生改变时，Vue组件会自动更新。</p>
<p>　　（简单来说，state中的属性都会被加入到响应式系统，而响应式系统会监听属性的变化，当属性发生变化时，会通知所有界面中用到该属性的地方，让界面发生刷新）</p>
<p>　　这就要求我们必须遵守一些Vuex对应的规则：<strong>提前在store中初始化好所需的属性</strong>。当给state中的<strong>对象添加新的属性</strong>时，使用下面的方式：</p>
<p>　　方式一：<strong>使用Vue.set(obj, ‘newProp’，123)</strong> 。这样做是响应式的，把在内部把‘newProp’也加入了响应式系统。</p>
<p>　　删除属性时，用<strong>Vue.delete(obj, ‘delProp’) .</strong></p>
<p>　　方式二：<strong>用新对象给旧对象重新赋值</strong>。</p>
<p>　　注意，如果使用<strong>obj.newProp&#x3D; ‘xx’<strong>，不是响应式的（因为之前没有这个obj.newProp的Dep）。此外，用</strong>delete</strong>方法删除属性也是非响应式的，因为这些方式不能加入到原来的响应式系统中。（这也是<strong>Vue响应式</strong>的内在要求，不仅是vuex，组件等等都是。）</p>
<p>　　6、Mutation的类型常量</p>
<p>　　在mutation中，我们定义了很多事件类型（也就是其中的方法名称）。当项目增大时，vuex管理的状态越来越多，需要更新状态的情况越来越多，那么意味这mutation的方法越来越多。使用者需要大量精力去记住这些方法，甚至在多个文件间来回切换，查看方法名称，很麻烦。</p>
<p>　　也就是说，有时候我们需要记mutation的type，当定义和commit的时候都会用到，但是两边复制粘贴，太麻烦了。这时候，可以使用mutation的类型常量。</p>
<p>　　首先，在store文件夹下，创建mutations-types.js文件。里面定义一些关于mutation类型的常量（并导出），例如下例，此时INCREMENT就相当于‘increment’。</p>
<p><img src="/2019/12/29/blog36/1803687-20191230152315624-265565573-1577951386184.png" alt="img"></p>
<p> 　<img src="/2019/12/29/blog36/1803687-20191230152240877-221426829-1577951387311.png" alt="img">（index.js） </p>
<p> 　然后，在App.vue导入这个常量。（不是默认导出，记得用大括号哦）</p>
<p>　　<img src="/2019/12/29/blog36/1803687-20191230152543450-1362617266-1577951392162.png" alt="img">（App.vue）</p>
<p> 　对应我们commit使用这个常量，就很简单了，不用来回看了。</p>
<p>　　<img src="/2019/12/29/blog36/1803687-20191230152643796-1488877844-1577954134780.png" alt="img"></p>
<p> 　但是我们还得保证mutation定义的时候，方法名没有写错，所以，我们也把这个常量导入到index.js中。</p>
<p>　　<img src="/2019/12/29/blog36/1803687-20191230152854482-2135310890-1577951397343.png" alt="img"></p>
<p> 　修改成[‘XX’]的方式，然后用常量代替。</p>
<p>　　<img src="/2019/12/29/blog36/1803687-20191230152834477-540601590-1577952043867.png" alt="img"></p>
<p> 　<img src="/2019/12/29/blog36/1803687-20191230152937800-199533397-1577951402121.png" alt="img"></p>
<p>　　7、actions的使用详解</p>
<p>　　通常情况下，<strong>vuex要求我们mutation中的方法必须是同步的</strong>。</p>
<p>　　主要的原因是当我们使用devtools时，可以devtools可以帮助我们捕捉mutation的快照。但是如果是异步操作，那么devtools将不能很好地追踪这个操作什么时候会完成。</p>
<p>　　 所以不要在mutation中进行异步操作。</p>
<p>　　但是在某些情况，我们确实想在vuex中进行一些异步操作，比如网络请求。</p>
<p>　　action类似于mutation，但是是用来代替mutation进行异步操作的。</p>
<p>　　action的基本使用：</p>
<p>　　action中定义的方法也有默认参数，但不是state，而是context（上下文），目前可以理解为store。但注意<strong>修改state的唯一途径是通过mutation</strong>。</p>
<p>　　<img src="/2019/12/29/blog36/1803687-20191230155630393-1250551510-1577951405233.png" alt="img"></p>
<p> 　然后由于执行的是异步操作，对应的App.vue组件使用的方法也要修改。使用**dispatch()**（派遣）。</p>
<p>　　<img src="/2019/12/29/blog36/1803687-20191230155832211-733195188-1577952043784.png" alt="img"></p>
<p> 　此时，进行的异步操作可以被devtools捕获了。</p>
<p>　　同样地，action也可以带参数的。</p>
<p>　　<img src="/2019/12/29/blog36/1803687-20191230160109705-1723705627-1577951411209.png" alt="img">（App.vue）</p>
<p>　　 <img src="/2019/12/29/blog36/1803687-20191230160040965-286866272-1577951412993.png" alt="img">（index.js）</p>
<p> 　如果我们想在异步操作完成的时候，出现提示信息。可以结合使用Promise（ES6新增）。即把异步操作进行Promise封装。</p>
<p>　　<img src="/2019/12/29/blog36/1803687-20191230160902792-1946914926-1577951418357.png" alt="img">（index.js）</p>
<p>　　然后在App.vue中使用then()，即执行异步请求成功后的操作。（相当于通过action中转，在返回Promise对象后使用then()函数）</p>
<p>　　<img src="/2019/12/29/blog36/1803687-20191230160739956-1544939159-1577951417352.png" alt="img">　</p>
<p>　　8、modules的使用</p>
<p>　　Vue使用单一状态树，那么也意味着很多状态都会交给Vuex管理，当应用变得很复杂时，即写states，mutations，actions，getters代码过多时，会显得store对象比较臃肿。</p>
<p>　　为解决这个问题，Vuex允许我们将store分割成模块（module），而每个模块拥有自己的states、mutations、actions、getters等。</p>
<p>　　<img src="/2019/12/29/blog36/1803687-20191230161950390-1149858214-1577951423427.png" alt="img"></p>
<p> 　取模块中的某状态时，是使用store.state.a（a是在store中的模块名），如果进一步取模块a的state某属性，假如name，直接使用store.state.a.name即可，不需要写成store.state.a.state.name。</p>
<p>　　在模块定义的mutation方法，在使用时，也是直接使用$state.commit(‘方法名’)使用方法，其会先在store中的mutation搜索该方法，如果没有，则去模块中搜索，从而调用。所以模块的方法名最后不要和stroe的mutation方法重复。</p>
<p>　　模块中的getters方法，也是类似于上述一样，直接通过普通的$store.getters.方法名来使用方法。</p>
<p>　　然后，模块中的getters的方法可以想之前说的一样，使用当前getters作为方法参数。</p>
<p>　　此外，模块中的getters的方法还可以有第三个默认参数，叫rootState，特指源store的state。</p>
<p>　　模块中的actions。之前提过，actions中的方法，里面有一个默认参数，即context（上下文），但注意，此时store.commit()，即context.commit()，这个store是模块自己的store。但是这个context里面有很多属性，包括根store和根getters。 </p>
<p>　　9、store文件夹的目录结构</p>
<p>　　当我们的vuex帮助我们管理过多的内容时，好的项目结构可以让我们的代码更加清晰。</p>
<p>　<img src="/2019/12/29/blog36/1803687-20191230164120283-1040247640-1577951427994.png" alt="img"></p>
<p> 　之前我们把所有关于vuex的代码写到一块了，当项目比较大时，不方便管理，所以需要进行构造好的目录结构，即对一些代码进行抽离。</p>
<p>　　state代码：（index.js里面）把state抽离成一个对象，放在store外面，然后在里面使用这个state对象。</p>
<p>　　<img src="/2019/12/29/blog36/1803687-20191230164512619-507305908-1577951430059.png" alt="img"></p>
<p> 　mutation：（重新创建一个mutations.js文件，在store目录下）</p>
<p>　　然后把index.js中的mutation对象写进去，再导出。最后在index.js中引用。</p>
<p>　　actions:也是类似上述的做法。（actions.js）</p>
<p>　　getters：也是类似上述的做法。（getters.js）</p>
<p>　　modules：新建一个modules文件夹（store目录下），由于模块可以有多个，然后在这个modules文件夹放置一个一个模块文件（.js文件，也是导出），最后在index.js按需引用（但引用的时候，最好是a: moduleA，给moduleA一个名字a）。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a><a class="post-meta__tags" href="/tags/%E6%A1%86%E6%9E%B6/">框架</a><a class="post-meta__tags" href="/tags/vue/">vue</a><a class="post-meta__tags" href="/tags/Vuex/">Vuex</a><a class="post-meta__tags" href="/tags/Vuex%E9%85%8D%E7%BD%AE/">Vuex配置</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/12/30/blog37/" title="前端框架Vue自学之axios（九）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">前端框架Vue自学之axios（九）</div></div></a></div><div class="next-post pull-right"><a href="/2019/12/27/blog34/" title="前端框架Vue自学之Vue router小案例TabBar（七）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">前端框架Vue自学之Vue router小案例TabBar（七）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2019/11/20/blog18/" title="前端学习之JavaScript的框架"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-11-20</div><div class="title">前端学习之JavaScript的框架</div></div></a></div><div><a href="/2019/12/03/blog19/" title="前端框架Vue学习的心得记录（基础篇）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-03</div><div class="title">前端框架Vue学习的心得记录（基础篇）</div></div></a></div><div><a href="/2019/12/06/blog20/" title="前端框架Vue学习的心得记录（深入了解组件）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-06</div><div class="title">前端框架Vue学习的心得记录（深入了解组件）</div></div></a></div><div><a href="/2019/12/09/blog22/" title="前端框架Vue学习的心得记录（可复用性&amp;组合）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-09</div><div class="title">前端框架Vue学习的心得记录（可复用性&amp;组合）</div></div></a></div><div><a href="/2019/12/10/blog24/" title="前端框架Vue学习的心得记录（规模化）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-10</div><div class="title">前端框架Vue学习的心得记录（规模化）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/blog_wxk.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">伍新奎</div><div class="author-info__description">前端开发工程师</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">96</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">150</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">68</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xinkuiwu"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vuex"><span class="toc-number">1.</span> <span class="toc-text">Vuex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81Vuex%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%9C%E7%94%A8%E8%A7%A3%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">一、Vuex概念和作用解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%8D%95%E7%95%8C%E9%9D%A2%E5%88%B0%E5%A4%9A%E7%95%8C%E9%9D%A2%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%88%87%E6%8D%A2"><span class="toc-number">3.</span> <span class="toc-text">二、单界面到多界面状态管理切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81Vuex%E6%A0%B8%E5%BF%83"><span class="toc-number">4.</span> <span class="toc-text">三、Vuex核心</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/23/blog96/" title="nestjs学习-5种http数据传输方式">nestjs学习-5种http数据传输方式</a><time datetime="2023-11-23T08:02:00.000Z" title="Created 2023-11-23 16:02:00">2023-11-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/23/blog95/" title="nestjs学习-快速掌握 Nest CLI">nestjs学习-快速掌握 Nest CLI</a><time datetime="2023-11-23T08:02:00.000Z" title="Created 2023-11-23 16:02:00">2023-11-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/15/blog90/" title="前端工程化- webpack | 项目打包webpack优化">前端工程化- webpack | 项目打包webpack优化</a><time datetime="2023-11-15T03:02:00.000Z" title="Created 2023-11-15 11:02:00">2023-11-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/01/blog94/" title="单元测试-jest搭建和使用">单元测试-jest搭建和使用</a><time datetime="2023-11-01T06:02:00.000Z" title="Created 2023-11-01 14:02:00">2023-11-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/20/blog93/" title="nodejs-PM2搭建和使用">nodejs-PM2搭建和使用</a><time datetime="2023-10-20T03:02:00.000Z" title="Created 2023-10-20 11:02:00">2023-10-20</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2023 By 伍新奎</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://lib.baomitu.com/fancyapps-ui/5.0.24/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div></div></body></html>