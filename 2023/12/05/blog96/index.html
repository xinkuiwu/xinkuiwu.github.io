<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>nestjs学习-5种http数据传输方式 | 伍新奎的博客空间</title><meta name="author" content="伍新奎"><meta name="copyright" content="伍新奎"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="对于前端来说，后端主要是提供 http 接口来传输数据，而这种数据传输的方式主要有 5 种：  url param query form-urlencoded form-data json  我们分别来看一下： url param我们可以把参数写在 url 中，比如： 12arduino复制代码http:&#x2F;&#x2F;guang.zxg&#x2F;person&#x2F;1111  这里的 1111 就是路径中的参数（url">
<meta property="og:type" content="article">
<meta property="og:title" content="nestjs学习-5种http数据传输方式">
<meta property="og:url" content="http://example.com/2023/12/05/blog96/index.html">
<meta property="og:site_name" content="伍新奎的博客空间">
<meta property="og:description" content="对于前端来说，后端主要是提供 http 接口来传输数据，而这种数据传输的方式主要有 5 种：  url param query form-urlencoded form-data json  我们分别来看一下： url param我们可以把参数写在 url 中，比如： 12arduino复制代码http:&#x2F;&#x2F;guang.zxg&#x2F;person&#x2F;1111  这里的 1111 就是路径中的参数（url">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/blog_wxk.jpg">
<meta property="article:published_time" content="2023-12-05T12:02:00.000Z">
<meta property="article:modified_time" content="2023-12-05T13:56:37.131Z">
<meta property="article:author" content="伍新奎">
<meta property="article:tag" content="nestjs">
<meta property="article:tag" content="http">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/blog_wxk.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/12/05/blog96/index.html"><link rel="preconnect" href="https://lib.baomitu.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lib.baomitu.com/font-awesome/6.4.2/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://lib.baomitu.com/fancyapps-ui/5.0.24/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://lib.baomitu.com/egjs-infinitegrid/4.10.1/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'nestjs学习-5种http数据传输方式',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-05 21:56:37'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/blog_wxk.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">96</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">150</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">68</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="伍新奎的博客空间"><span class="site-name">伍新奎的博客空间</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">nestjs学习-5种http数据传输方式</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">Created</span><time datetime="2023-12-05T12:02:00.000Z" title="Created 2023-12-05 20:02:00">2023-12-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/nestjs/">nestjs</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/nestjs/http/">http</a></span></div><div class="meta-secondline"></div></div></div><article class="post-content" id="article-container"><p>对于前端来说，后端主要是提供 http 接口来传输数据，而这种数据传输的方式主要有 5 种：</p>
<ul>
<li>url param</li>
<li>query</li>
<li>form-urlencoded</li>
<li>form-data</li>
<li>json</li>
</ul>
<p>我们分别来看一下：</p>
<h2 id="url-param"><a href="#url-param" class="headerlink" title="url param"></a>url param</h2><p>我们可以把参数写在 url 中，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arduino</span><br><span class="line">复制代码http://guang.zxg/person/1111</span><br></pre></td></tr></table></figure>

<p>这里的 1111 就是路径中的参数（url param），服务端框架或者单页应用的路由都支持从 url 中取出参数。</p>
<h2 id="query"><a href="#query" class="headerlink" title="query"></a>query</h2><p>通过 url 中 ？后面的用 &amp; 分隔的字符串传递数据。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ini</span><br><span class="line">复制代码http://guang.zxg/person?name=guang&amp;age=20</span><br></pre></td></tr></table></figure>

<p>这里的 name 和 age 就是 query 传递的数据。<br>其中非英文的字符和一些特殊字符要经过编码，可以使用 encodeURIComponent 的 api 来编码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javascript</span><br><span class="line">复制代码const query = &quot;?name=&quot; + encodeURIComponent(&#x27;光&#x27;) + &quot;&amp;age=20&quot;</span><br><span class="line"></span><br><span class="line">// ?name=%E5%85%89&amp;age=20</span><br></pre></td></tr></table></figure>

<p>或者使用封装了一层的 query-string 库来处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">javascript</span><br><span class="line">复制代码const queryString = require(&#x27;query-string&#x27;);</span><br><span class="line"></span><br><span class="line">queryString.stringify(&#123;</span><br><span class="line">  name: &#x27;光&#x27;,</span><br><span class="line">  age: 20</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// ?name=%E5%85%89&amp;age=20</span><br></pre></td></tr></table></figure>

<h2 id="form-urlencoded"><a href="#form-urlencoded" class="headerlink" title="form-urlencoded"></a>form-urlencoded</h2><p>直接用 form 表单提交数据就是这种，它和 query 字符串的方式的区别只是放在了 body 里，然后指定下 content-type 是 application&#x2F;x-www-form-urlencoded。<br><img src="/2023/12/05/blog96/1700813709301-0c94247a-5a56-4e5a-921d-bdf8d1e42833.webp"><br>因为内容也是 query 字符串，所以也要用 encodeURIComponent 的 api 或者 query-string 库处理下。<br>这种格式也很容易理解，get 是把数据拼成 query 字符串放在 url 后面，于是表单的 post 提交方式的时候就直接用相同的方式把数据放在了 body 里。<br>通过 &amp; 分隔的 form-urlencoded 的方式需要对内容做 url encode，如果传递大量的数据，比如上传文件的时候就不是很合适了，因为文件 encode 一遍的话太慢了，这时候就可以用 form-data。</p>
<h2 id="form-data"><a href="#form-data" class="headerlink" title="form-data"></a>form-data</h2><p>form data 不再是通过 &amp; 分隔数据，而是用 ——— + 一串数字做为 boundary 分隔符。因为不是 url 的方式了，自然也不用再做 url encode。<br><img src="/2023/12/05/blog96/1700813709317-619577a5-72f0-4133-9613-33971b4b98fd.webp"><br>form-data 需要指定 content type 为 multipart&#x2F;form-data，然后指定 boundary 也就是分割线。<br>body 里面就是用 boundary 分隔符分割的内容。<br>很明显，这种方式适合传输文件，而且可以传输多个文件。<br>但是毕竟多了一些只是用来分隔的 boundary，所以请求体会增大。</p>
<h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><p>form-urlencoded 需要对内容做 url encode，而 form data 则需要加很长的 boundary，两种方式都有一些缺点。如果只是传输 json 数据的话，不需要用这两种。<br>可以直接指定content type 为 application&#x2F;json 就行：<br><img src="/2023/12/05/blog96/1700813709358-81e59994-8e6b-4d72-a5f3-b92b225aa16b.webp"><br>我们平时传输 json 数据基本用的是这种。<br>那这 5 种接口怎么用 Nest 实现呢？<br>我们分别看一下：<br>首先我们要把 Nest 服务端跑起来，并且支持 api 接口、静态页面。<br>Nest 创建一个 crud 服务是非常快的，只需要这么几步：</p>
<ul>
<li>安装 @nestjs&#x2F;cli，使用 nest new xxx 创建一个 Nest 的项目，</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arduino</span><br><span class="line">复制代码nest new xxx</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/05/blog96/1700813709334-f4d36c97-0067-4267-a0e8-f1a98ceecf7d.webp"></p>
<ul>
<li>在根目录执行 nest g resource person 快速生成 person 模块的 crud 代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">复制代码nest g resource person</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/05/blog96/1700813709360-970bccf4-0e17-4971-a380-03f9de2cba6f.webp"></p>
<ul>
<li>nest start –watch 启动 Nest 服务</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sql</span><br><span class="line">复制代码nest start --watch</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/05/blog96/1700813710117-256e833b-c8a1-4eb7-8bc3-37015d5c38c3.webp"><br>这样一个有 person 的 crud 接口的服务就跑起来了。<br>服务跑起来以后是这样的<br><img src="/2023/12/05/blog96/1700813709928-9bd1085b-2bca-41ce-87ec-c3c5ea3d0cf3.webp"><br>打印出了有哪些接口可以用，可以在浏览器测试下：<br><img src="/2023/12/05/blog96/1700813710702-1c2d6952-baec-4dfa-970d-6f96d94b635c.webp"><br>api 接口跑通了，再支持下静态资源的访问：<br>main.ts 是负责启动 Nest 的 ioc 容器的，调用下 useStaticAssets 来支持静态资源的请求：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typescript</span><br><span class="line">复制代码import &#123; NestExpressApplication &#125; from &#x27;@nestjs/platform-express&#x27;;</span><br><span class="line"></span><br><span class="line">async function bootstrap() &#123;</span><br><span class="line">  const app = await NestFactory.create&lt;NestExpressApplication&gt;(AppModule);</span><br><span class="line">  app.useStaticAssets(&#x27;public&#x27;, &#123; prefix: &#x27;/static&#x27;&#125;);</span><br><span class="line">  await app.listen(3000);</span><br><span class="line">&#125;</span><br><span class="line">bootstrap();</span><br></pre></td></tr></table></figure>

<p>（注意要给 create 方法传入 NestExpressApplication 的泛型参数才有 useStaticAssets这些方法）<br>我们指定 prefix 为 static，然后在静态文件目录 public 下添加一个 html：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">html</span><br><span class="line">复制代码&lt;html&gt;</span><br><span class="line">&lt;body&gt;hello&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>重启服务，然后浏览器访问下试试：<br><img src="/2023/12/05/blog96/1700813709926-36a58040-8a08-4f2f-a4c4-28fe982b75de.webp"><br>api 接口和静态资源的访问都支持了，接下来就分别实现下 5 种前后端 http 数据传输的方式吧。</p>
<h2 id="url-param-1"><a href="#url-param-1" class="headerlink" title="url param"></a>url param</h2><p>url param 是 url 中的参数，Nest 里通过 :参数名 的方式来声明（比如下面的 :id），然后通过 @Param(参数名) 的装饰器取出来注入到 controller：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typescript</span><br><span class="line">复制代码@Controller(&#x27;api/person&#x27;)</span><br><span class="line">export class PersonController &#123;</span><br><span class="line">  @Get(&#x27;:id&#x27;)</span><br><span class="line">  urlParam(@Param(&#x27;id&#x27;) id: string) &#123;</span><br><span class="line">    return `received: id=$&#123;id&#125;`;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Controller(‘api&#x2F;person’) 的路由和 @Get(‘:id’) 的路由会拼到一起，也就是只有 &#x2F;api&#x2F;person&#x2F;xxx 的 get 请求才会走到这个方法。<br>前端代码就是一个 get 方法，参数放在 url 里：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">html</span><br><span class="line">复制代码&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;script src=&quot;https://unpkg.com/axios@0.24.0/dist/axios.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        async function urlParam() &#123;</span><br><span class="line">            const res = await axios.get(&#x27;/api/person/1&#x27;);</span><br><span class="line">            console.log(res);            </span><br><span class="line">        &#125;</span><br><span class="line">        urlParam();</span><br><span class="line">   &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<p>启动服务，在浏览器访问下：<br><img src="/2023/12/05/blog96/1700813709968-68032e87-7075-44d6-b2b9-df7f0a20ac9f.webp"><br>控制台打印了服务端返回的消息，证明服务端拿到了通过 url param 传递的数据。<br>通过 url 传递数据的方式除了 url param 还有 query：</p>
<h2 id="query-1"><a href="#query-1" class="headerlink" title="query"></a>query</h2><p>query 是 url 中 ? 后的字符串，需要做 url encode。<br>在 Nest 里，通过 @Query 装饰器来取：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typescript</span><br><span class="line">复制代码@Controller(&#x27;api/person&#x27;)</span><br><span class="line">export class PersonController &#123;</span><br><span class="line">  @Get(&#x27;find&#x27;)</span><br><span class="line">  query(@Query(&#x27;name&#x27;) name: string, @Query(&#x27;age&#x27;) age: number) &#123;</span><br><span class="line">    return `received: name=$&#123;name&#125;,age=$&#123;age&#125;`;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这个 find 的路由要放到 :id 的路由前面，因为 Nest 是从上往下匹配的，如果放在后面，那就匹配到 :id 的路由了。<br><img src="/2023/12/05/blog96/1700813710254-eaf60251-e97f-4f60-b836-28fa1641bafd.webp"><br>前端代码同样是通过 axios 发送一个 get 请求：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">html</span><br><span class="line">复制代码&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;script src=&quot;https://unpkg.com/axios@0.24.0/dist/axios.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        async function query() &#123;</span><br><span class="line">            const res = await axios.get(&#x27;/api/person/find&#x27;, &#123;</span><br><span class="line">                params: &#123;</span><br><span class="line">                    name: &#x27;光&#x27;,</span><br><span class="line">                    age: 20</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            console.log(res);            </span><br><span class="line">        &#125;</span><br><span class="line">        query();</span><br><span class="line">   &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>参数通过 params 指定，axios 会做 url encode，不需要自己做。<br>然后测试下：<br><img src="/2023/12/05/blog96/1700813710340-d0c57027-ac1d-45df-938e-97fc4763b828.webp"><br>服务端成功接受了我们通过 query 传递的数据。<br>上面两种（url param、query)是通过 url 传递数据的方式，下面 3 种是通过 body 传递数据。</p>
<h2 id="form-urlencoded-1"><a href="#form-urlencoded-1" class="headerlink" title="form urlencoded"></a>form urlencoded</h2><p>form urlencoded 是通过 body 传输数据，其实是把 query 字符串放在了 body 里，所以需要做 url encode：<br><img src="/2023/12/05/blog96/1700813710322-419e2d6c-7569-4ece-8fd7-b32a48b5cf24.webp"><br>用 Nest 接收的话，使用 @Body 装饰器，Nest 会解析请求体，然后注入到 dto 中。<br>dto 是 data transfer object，就是用于封装传输的数据的对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typescript</span><br><span class="line">复制代码export class CreatePersonDto &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typescript</span><br><span class="line">复制代码import &#123; CreatePersonDto &#125; from &#x27;./dto/create-person.dto&#x27;;</span><br><span class="line"></span><br><span class="line">@Controller(&#x27;api/person&#x27;)</span><br><span class="line">export class PersonController &#123;</span><br><span class="line">  @Post()</span><br><span class="line">  body(@Body() createPersonDto: CreatePersonDto) &#123;</span><br><span class="line">    return `received: $&#123;JSON.stringify(createPersonDto)&#125;`</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前端代码使用 post 方式请求，指定 content type 为 application&#x2F;x-www-form-urlencoded，用 qs 做下 url encode：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">html</span><br><span class="line">复制代码&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;script src=&quot;https://unpkg.com/axios@0.24.0/dist/axios.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;https://unpkg.com/qs@6.10.2/dist/qs.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        async function formUrlEncoded() &#123;</span><br><span class="line">            const res = await axios.post(&#x27;/api/person&#x27;, Qs.stringify(&#123;</span><br><span class="line">                name: &#x27;光&#x27;,</span><br><span class="line">                age: 20</span><br><span class="line">            &#125;), &#123;</span><br><span class="line">                headers: &#123; &#x27;content-type&#x27;: &#x27;application/x-www-form-urlencoded&#x27; &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            console.log(res);  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        formUrlEncoded();</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>测试下：<br><img src="/2023/12/05/blog96/1700813710725-0e0bf523-2a10-4f74-8fd9-3ba1c3c9a840.webp"><br>服务端成功的接收到了数据。<br>其实比起 form urlencoded，使用 json 来传输更常用一些：</p>
<h2 id="json-1"><a href="#json-1" class="headerlink" title="json"></a>json</h2><p>json 需要指定 content-type 为 application&#x2F;json，内容会以 JSON 的方式传输：<br><img src="/2023/12/05/blog96/1700813710682-a46e98a7-b0d4-4f81-87d1-269d471afa89.webp"><br>后端代码同样使用 @Body 来接收，不需要做啥变动。form urlencoded 和 json 都是从 body 取值，Nest 内部会根据 content type 做区分，使用不同的解析方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typescript</span><br><span class="line">复制代码@Controller(&#x27;api/person&#x27;)</span><br><span class="line">export class PersonController &#123;</span><br><span class="line">  @Post()</span><br><span class="line">  body(@Body() createPersonDto: CreatePersonDto) &#123;</span><br><span class="line">    return `received: $&#123;JSON.stringify(createPersonDto)&#125;`</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前端代码使用 axios 发送 post 请求，默认传输 json 就会指定 content type 为 application&#x2F;json，不需要手动指定：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">html</span><br><span class="line">复制代码&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;script src=&quot;https://unpkg.com/axios@0.24.0/dist/axios.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        async function json() &#123;</span><br><span class="line">            const res = await axios.post(&#x27;/api/person&#x27;, &#123;</span><br><span class="line">                name: &#x27;光&#x27;,</span><br><span class="line">                age: 20</span><br><span class="line">            &#125;);</span><br><span class="line">            console.log(res);     </span><br><span class="line">        &#125;</span><br><span class="line">        json();</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>测试下：<br><img src="/2023/12/05/blog96/1700813710753-b26042bf-f4ee-4213-ab02-8ad9afa922bb.webp"><br>服务端成功接收到了通过 json 传递的数据！<br>json 和 form urlencoded 都不适合传递文件，想传输文件要用 form data：</p>
<h2 id="form-data-1"><a href="#form-data-1" class="headerlink" title="form data"></a>form data</h2><p>form data 是用 ——– 作为 boundary 分隔传输的内容的：<br><img src="/2023/12/05/blog96/1700813710979-a6bf54f6-4b0f-4403-9624-bea16b83b574.webp"><br>Nest 解析 form data 使用 FilesInterceptor 的拦截器，用 @UseInterceptors 装饰器启用，然后通过 @UploadedFiles 来取。非文件的内容，同样是通过 @Body 来取。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typescript</span><br><span class="line">复制代码import &#123; AnyFilesInterceptor &#125; from &#x27;@nestjs/platform-express&#x27;;</span><br><span class="line">import &#123; CreatePersonDto &#125; from &#x27;./dto/create-person.dto&#x27;;</span><br><span class="line"></span><br><span class="line">@Controller(&#x27;api/person&#x27;)</span><br><span class="line">export class PersonController &#123;</span><br><span class="line">  @Post(&#x27;file&#x27;)</span><br><span class="line">  @UseInterceptors(AnyFilesInterceptor(&#123;</span><br><span class="line">      dest: &#x27;uploads/&#x27;</span><br><span class="line">  &#125;))</span><br><span class="line">  body2(@Body() createPersonDto: CreatePersonDto, @UploadedFiles() files: Array&lt;Express.Multer.File&gt;) &#123;</span><br><span class="line">    console.log(files);</span><br><span class="line">    return `received: $&#123;JSON.stringify(createPersonDto)&#125;`</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步需要</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">css</span><br><span class="line">复制代码npm i -D @types/multer</span><br></pre></td></tr></table></figure>

<p>引入相关类型声明。<br>前端代码使用 axios 发送 post 请求，指定 content type 为 multipart&#x2F;form-data：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">html</span><br><span class="line">复制代码&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;script src=&quot;https://unpkg.com/axios@0.24.0/dist/axios.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input id=&quot;fileInput&quot; type=&quot;file&quot; multiple/&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const fileInput = document.querySelector(&#x27;#fileInput&#x27;);</span><br><span class="line"></span><br><span class="line">        async function formData() &#123;</span><br><span class="line">            const data = new FormData();</span><br><span class="line">            data.set(&#x27;name&#x27;,&#x27;光&#x27;);</span><br><span class="line">            data.set(&#x27;age&#x27;, 20);</span><br><span class="line">            data.set(&#x27;file1&#x27;, fileInput.files[0]);</span><br><span class="line">            data.set(&#x27;file2&#x27;, fileInput.files[1]);</span><br><span class="line"></span><br><span class="line">            const res = await axios.post(&#x27;/api/person/file&#x27;, data, &#123;</span><br><span class="line">                headers: &#123; &#x27;content-type&#x27;: &#x27;multipart/form-data&#x27; &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            console.log(res);     </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fileInput.onchange = formData;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>file input 指定 multiple 可以选择多个文件。<br>测试下：<br><img src="/2023/12/05/blog96/1700813711021-6ffcc570-4e40-4d45-b33a-8bbcaf93df0f.webp"><br>服务端接收到了 name 和 age：<br><img src="/2023/12/05/blog96/1700813710991-540c4ecf-3b78-4ea9-b7eb-ad7820d85558.webp"><br>去服务器控制台看下：<br><img src="/2023/12/05/blog96/1700813711078-721fe6d4-5c95-4336-a92e-4094553e9d89.webp"><br><img src="/2023/12/05/blog96/1700813711112-92194908-a55e-4577-8780-68e7ed551987.webp"><br>可以看到，服务器成功的接收到了我们上传的文件。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们用 axios 发送请求，使用 Nest 起后端服务，实现了 5 种 http&#x2F;https 的数据传输方式：<br>其中前两种是 url 中的：</p>
<ul>
<li><strong>url param</strong>： url 中的参数，Nest 中使用 @Param 来取</li>
<li><strong>query</strong>：url 中 ? 后的字符串，Nest 中使用 @Query 来取</li>
</ul>
<p>后三种是 body 中的：</p>
<ul>
<li><strong>form urlencoded</strong>： 类似 query 字符串，只不过是放在 body 中。Nest 中使用 @Body 来取，axios 中需要指定 content type 为 application&#x2F;x-www-form-urlencoded，并且对数据用 qs 或者 query-string 库做 url encode</li>
<li><strong>json</strong>： json 格式的数据。Nest 中使用 @Body 来取，axios 中不需要单独指定 content type，axios 内部会处理。</li>
<li><strong>form data</strong>：通过 —– 作为 boundary 分隔的数据。主要用于传输文件，Nest 中要使用 FilesInterceptor 来处理其中的 binary 字段，用 @UseInterceptors 来启用，其余字段用 @Body 来取。axios 中需要指定 content type 为 multipart&#x2F;form-data，并且用 FormData 对象来封装传输的内容。</li>
</ul>
<p>这 5 种 http 的传输数据的方式覆盖了绝大多数开发场景，如果你想进阶全栈，理解这 5 种接口是首先要做到的。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/nestjs/">nestjs</a><a class="post-meta__tags" href="/tags/http/">http</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/11/23/blog95/" title="nestjs学习-快速掌握 Nest CLI"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">nestjs学习-快速掌握 Nest CLI</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2022/02/21/blog65/" title="NestJS 中使用esm"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-21</div><div class="title">NestJS 中使用esm</div></div></a></div><div><a href="/2022/03/16/blog66/" title="业界mysql的实践方案调研"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-16</div><div class="title">业界mysql的实践方案调研</div></div></a></div><div><a href="/2023/11/23/blog95/" title="nestjs学习-快速掌握 Nest CLI"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-23</div><div class="title">nestjs学习-快速掌握 Nest CLI</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/blog_wxk.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">伍新奎</div><div class="author-info__description">前端开发工程师</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">96</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">150</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">68</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xinkuiwu"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#url-param"><span class="toc-number">1.</span> <span class="toc-text">url param</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#query"><span class="toc-number">2.</span> <span class="toc-text">query</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#form-urlencoded"><span class="toc-number">3.</span> <span class="toc-text">form-urlencoded</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#form-data"><span class="toc-number">4.</span> <span class="toc-text">form-data</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#json"><span class="toc-number">5.</span> <span class="toc-text">json</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#url-param-1"><span class="toc-number">6.</span> <span class="toc-text">url param</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#query-1"><span class="toc-number">7.</span> <span class="toc-text">query</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#form-urlencoded-1"><span class="toc-number">8.</span> <span class="toc-text">form urlencoded</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#json-1"><span class="toc-number">9.</span> <span class="toc-text">json</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#form-data-1"><span class="toc-number">10.</span> <span class="toc-text">form data</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">11.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/05/blog96/" title="nestjs学习-5种http数据传输方式">nestjs学习-5种http数据传输方式</a><time datetime="2023-12-05T12:02:00.000Z" title="Created 2023-12-05 20:02:00">2023-12-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/23/blog95/" title="nestjs学习-快速掌握 Nest CLI">nestjs学习-快速掌握 Nest CLI</a><time datetime="2023-11-23T08:02:00.000Z" title="Created 2023-11-23 16:02:00">2023-11-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/15/blog90/" title="前端工程化- webpack | 项目打包webpack优化">前端工程化- webpack | 项目打包webpack优化</a><time datetime="2023-11-15T03:02:00.000Z" title="Created 2023-11-15 11:02:00">2023-11-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/01/blog94/" title="单元测试-jest搭建和使用">单元测试-jest搭建和使用</a><time datetime="2023-11-01T06:02:00.000Z" title="Created 2023-11-01 14:02:00">2023-11-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/20/blog93/" title="nodejs-PM2搭建和使用">nodejs-PM2搭建和使用</a><time datetime="2023-10-20T03:02:00.000Z" title="Created 2023-10-20 11:02:00">2023-10-20</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2023 By 伍新奎</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://lib.baomitu.com/fancyapps-ui/5.0.24/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div></div></body></html>