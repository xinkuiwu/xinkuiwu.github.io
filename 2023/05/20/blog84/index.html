<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>vue2使用typescript | composition API + tsc or sfc | 伍新奎的博客空间</title><meta name="author" content="伍新奎"><meta name="copyright" content="伍新奎"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="vue2使用typescript | composition API + tsc or sfcvue2升级到typescript的方案有很多种。vue2比较令人诟病的地方还是对ts的支持，对ts支持不好是vue2不适合大型项目的一个重要原因。其根本原因是Vue依赖单个this上下文来公开属性，并且vue中的this比在普通的javascript更具魔力（如methods对象下的单个method中的">
<meta property="og:type" content="article">
<meta property="og:title" content="vue2使用typescript | composition API + tsc or sfc">
<meta property="og:url" content="http://example.com/2023/05/20/blog84/index.html">
<meta property="og:site_name" content="伍新奎的博客空间">
<meta property="og:description" content="vue2使用typescript | composition API + tsc or sfcvue2升级到typescript的方案有很多种。vue2比较令人诟病的地方还是对ts的支持，对ts支持不好是vue2不适合大型项目的一个重要原因。其根本原因是Vue依赖单个this上下文来公开属性，并且vue中的this比在普通的javascript更具魔力（如methods对象下的单个method中的">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/blog_wxk.jpg">
<meta property="article:published_time" content="2023-05-20T03:01:00.000Z">
<meta property="article:modified_time" content="2023-12-05T10:19:01.701Z">
<meta property="article:author" content="伍新奎">
<meta property="article:tag" content="vue">
<meta property="article:tag" content="typescript">
<meta property="article:tag" content="composition">
<meta property="article:tag" content="sfc">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/blog_wxk.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/05/20/blog84/index.html"><link rel="preconnect" href="https://lib.baomitu.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lib.baomitu.com/font-awesome/6.4.2/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://lib.baomitu.com/fancyapps-ui/5.0.24/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://lib.baomitu.com/egjs-infinitegrid/4.10.1/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'vue2使用typescript | composition API + tsc or sfc',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-05 18:19:01'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/blog_wxk.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">96</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">150</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">68</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="伍新奎的博客空间"><span class="site-name">伍新奎的博客空间</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">vue2使用typescript | composition API + tsc or sfc</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">Created</span><time datetime="2023-05-20T03:01:00.000Z" title="Created 2023-05-20 11:01:00">2023-05-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/vue/">vue</a></span></div><div class="meta-secondline"></div></div></div><article class="post-content" id="article-container"><h1 id="vue2使用typescript-composition-API-tsc-or-sfc"><a href="#vue2使用typescript-composition-API-tsc-or-sfc" class="headerlink" title="vue2使用typescript | composition API + tsc or sfc"></a>vue2使用typescript | composition API + tsc or sfc</h1><p>vue2升级到typescript的方案有很多种。<br>vue2比较令人诟病的地方还是对ts的支持，对ts支持不好是vue2不适合大型项目的一个重要原因。<br>其根本原因是Vue依赖单个this上下文来公开属性，并且vue中的this比在普通的javascript更具魔力（如methods对象下的单个method中的this并不指向methods，而是指向vue实例）。换句话说，尤大大在设计Option API时并没有考虑对ts引用的支持）。（由于Vue2.x版本有设计断层，导致很多类型是通过declare方式推导出，而不是基于class的API，这也是为什么Vue3.0用typescript重写的原因之一。）<br>方案：<br><a name="Px3au"></a></p>
<h1 id="传统方案：vue-property-decorator-vue-class-component-vue-facing-decorator"><a href="#传统方案：vue-property-decorator-vue-class-component-vue-facing-decorator" class="headerlink" title="传统方案：vue-property-decorator | vue class component | vue-facing-decorator"></a>传统方案：vue-property-decorator | vue class component | vue-facing-decorator</h1><p>vue2对ts的支持主要是通过vue class component，vue-property-decorator这里主要依赖装饰器。<br>vue-property-decorator的用法：<br><a target="_blank" rel="noopener" href="https://github.com/kaorun343/vue-property-decorator">https://github.com/kaorun343/vue-property-decorator</a><br>目前该库已经不积极维护了，如果继续使用类组件的装饰器的写法，作者推荐使用vue-facing-decorator<br>vue-facing-decorator： <a target="_blank" rel="noopener" href="https://github.com/facing-dev/vue-facing-decorator">https://github.com/facing-dev/vue-facing-decorator</a></p>
<p><a name="oStm2"></a></p>
<h4 id="vue-property-decorator方案缺点"><a href="#vue-property-decorator方案缺点" class="headerlink" title="vue-property-decorator方案缺点"></a>vue-property-decorator方案缺点</h4><ul>
<li>vue class component与js的vue组件差异太大，另外需要引入额外的库，学习成本大幅度增高。</li>
<li>依赖于装饰器语法。而目前装饰器目前还处于stage2阶段(可查看tc39 decorators)，在实现细节上还存在许多不确定性，这使其成为一个相当危险的基础。</li>
<li>复杂性增高。采用Vue Class Component且需要使用额外的库，相比于简单的js vue组件，显然复杂化。<br><a name="Jq0OT"></a></li>
</ul>
<h1 id="tsx组合方案：Vue-Components-TypeScript"><a href="#tsx组合方案：Vue-Components-TypeScript" class="headerlink" title="tsx组合方案：Vue Components + TypeScript"></a>tsx组合方案：Vue Components + TypeScript</h1><p>如果写过react，这个方案风格会更舒服。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span>, &#123; <span class="title class_">VueConstructor</span>, <span class="title class_">CreateElement</span>, <span class="title class_">VNode</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line">interface <span class="title class_">InputInstance</span> <span class="keyword">extends</span> <span class="title class_">Vue</span> &#123;</span><br><span class="line">  <span class="attr">composing</span>: boolean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (<span class="title class_">Vue</span> <span class="keyword">as</span> <span class="title class_">VueConstructor</span>&lt;<span class="title class_">InputInstance</span>&gt;).<span class="title function_">extend</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;demo-input&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;&#125;,</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="comment">// TODO 更Vue其它组件一样</span></span><br><span class="line">  <span class="title function_">render</span>(<span class="attr">h</span>: <span class="title class_">CreateElement</span>): <span class="title class_">VNode</span> &#123;</span><br><span class="line">    <span class="comment">// TODO 逻辑</span></span><br><span class="line">    <span class="keyword">const</span> classes = []</span><br><span class="line">    <span class="keyword">const</span> wrapperAttrs = &#123;...<span class="variable language_">this</span>.<span class="property">$attrs</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> wrapperEvents = &#123;...<span class="variable language_">this</span>.<span class="property">$listeners</span>&#125;;</span><br><span class="line">    <span class="comment">// JSX 语法</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#123;classes&#125;</span> &#123;<span class="attr">...</span>&#123; <span class="attr">attrs:</span> <span class="attr">wrapperAttrs</span>, <span class="attr">on:</span> <span class="attr">wrapperEvents</span> &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><a name="ZUyfH"></a></p>
<h2 id="Vuex-Store的痛"><a href="#Vuex-Store的痛" class="headerlink" title="Vuex Store的痛"></a>Vuex Store的痛</h2><p>在ts里面使用vuex非常的蛋疼。<br>vuex ts版相关的<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://www.npmjs.com/package/vuex-class">vuex-class</a>和<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://www.npmjs.com/package/vuex-module-decorators">vuex-module-decorators</a>两个库应该是目前用的最多的如果是老旧项目，个人推荐先使用vuex-class过度。</p>
<p><a name="pBhpL"></a></p>
<h1 id="tsx-composion-API"><a href="#tsx-composion-API" class="headerlink" title="tsx+composion API"></a>tsx+composion API</h1><p>当迁移到 Vue 3 时，只需简单的将 @vue&#x2F;composition-api 替换成 vue 即可。你现有的代码几乎无需进行额外的改动。可开启 .ts、.tsx 支持。<br>问题1：是否有必要使用类vue-property-decorator？<br>没这个必要，这个写法如果后续迁移vue3还得改，还存在一定学习成本，这里本意只是引入使用ts，顺便学习一下vue3的组合式API写法。</p>
<p><a name="itwBv"></a></p>
<h2 id="动机与目的"><a href="#动机与目的" class="headerlink" title="动机与目的"></a>动机与目的</h2><ul>
<li>更好的逻辑复用与代码组织 <ol>
<li>随着功能的增长，复杂组件的代码变得越来越难以阅读和理解。</li>
<li>目前缺少一种简洁且低成本的机制来提取和重用多个组件之间的逻辑。</li>
</ol>
</li>
<li>更好的类型推导 Vue 当前的 API 在集成 TypeScript 时遇到了不小的麻烦，其主要原因是 Vue 依靠一个简单的 this 上下文来暴露 property，我们现在使用 this 的方式是比较微妙的。（比如 methods 选项下的函数的 this 是指向组件实例的，而不是这个 methods 对象）。</li>
<li>mixins 带来的问题 <ol>
<li>渲染上下文中暴露的 property 来源不清晰。例如在阅读一个运用了多个 mixin 的模板时，很难看出某个 property 是从哪一个 mixin 中注入的。</li>
<li>命名空间冲突。Mixin 之间的 property 和方法可能有冲突，同时高阶组件也可能和预期的 prop 有命名冲突。</li>
<li>性能方面，高阶组件和无渲染组件需要额外的有状态的组件实例，从而使得性能有所损耗。<br><a name="dQ2dy"></a></li>
</ol>
</li>
</ul>
<h2 id="与现有的-API-配合"><a href="#与现有的-API-配合" class="headerlink" title="与现有的 API 配合"></a>与现有的 API 配合</h2><p>组合式 API 完全可以和现有的基于选项的 API 配合使用。</p>
<ul>
<li>组合式 API 会在 2.x 的选项 (data、computed 和 methods) 之前解析，并且不能提前访问这些选项中定义的 property。</li>
<li>setup() 函数返回的 property 将会被暴露给 this。它们在 2.x 的选项中可以访问到。<br><a name="MDXIy"></a></li>
</ul>
<h1 id="最终选择-：vue2-7升级-typescript支持"><a href="#最终选择-：vue2-7升级-typescript支持" class="headerlink" title="[最终选择]：vue2.7升级+typescript支持"></a>[最终选择]：vue2.7升级+typescript支持</h1><p>vue2.7是vue2最新的次级版本，提供了内置的组合式API支持。</p>
<p><a name="MTPYU"></a></p>
<h2 id="什么是组合式-API？"><a href="#什么是组合式-API？" class="headerlink" title="什么是组合式 API？"></a>什么是组合式 API？</h2><p>组合式 API (Composition API) 是一系列 API 的集合，使我们可以使用函数而不是声明选项的方式书写 Vue 组件。它是一个概括性的术语，涵盖了以下方面的 API：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/reactivity-core.html">响应式 API</a>：例如 ref() 和 reactive()，使我们可以直接创建响应式状态、计算属性和侦听器。</li>
<li><a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/composition-api-lifecycle.html">生命周期钩子</a>：例如 onMounted() 和 onUnmounted()，使我们可以在组件各个生命周期阶段添加逻辑。</li>
<li><a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/composition-api-dependency-injection.html">依赖注入</a>：例如 provide() 和 inject()，使我们可以在使用响应式 API 时，利用 Vue 的依赖注入系统。</li>
</ul>
<p>组合式 API 是 Vue 3 及 <a target="_blank" rel="noopener" href="https://blog.vuejs.org/posts/vue-2-7-naruto.html">Vue 2.7</a> 的内置功能。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref, onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应式状态</span></span><br><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更改状态、触发更新的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">  count.<span class="property">value</span>++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生命周期钩子</span></span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`计数器初始值为 <span class="subst">$&#123;count.value&#125;</span>。`</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">clic</span></span></span></span><br></pre></td></tr></table></figure>

<p>虽然这套 API 的风格是基于函数的组合，但组合式 API 并不是函数式编程。组合式 API 是以 Vue 中数据可变的、细粒度的响应性系统为基础的，而函数式编程通常强调数据不可变。<br><a name="BaxPP"></a></p>
<h2 id="为什么要有组合式-API？"><a href="#为什么要有组合式-API？" class="headerlink" title="为什么要有组合式 API？"></a>为什么要有组合式 API？</h2><p><a name="jYDTL"></a></p>
<h3 id="更好的逻辑复用"><a href="#更好的逻辑复用" class="headerlink" title="更好的逻辑复用"></a>更好的逻辑复用</h3><p>组合式 API 最基本的优势是它使我们能够通过<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/reusability/composables.html">组合函数</a>来实现更加简洁高效的逻辑复用。在选项式 API 中我们主要的逻辑复用机制是 mixins，而组合式 API 解决了 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/reusability/composables.html#vs-mixins">mixins 的所有缺陷</a>。<br><a name="rgWEf"></a></p>
<h3 id="更灵活的代码组织"><a href="#更灵活的代码组织" class="headerlink" title="更灵活的代码组织"></a>更灵活的代码组织</h3><p>许多用户喜欢选项式 API 的原因是它在默认情况下就能够让人写出有组织的代码：大部分代码都自然地被放进了对应的选项里。然而，选项式 API 在单个组件的逻辑复杂到一定程度时，会面临一些无法忽视的限制。这些限制主要体现在需要处理多个<strong>逻辑关注点</strong>的组件中，这是我们在许多 Vue 2 的实际案例中所观察到的。<br>处理相同逻辑关注点的代码被强制拆分在了不同的选项中，位于文件的不同部分。在一个几百行的大组件中，要读懂代码中的一个逻辑关注点，需要在文件中反复上下滚动，这并不理想。另外，如果我们想要将一个逻辑关注点抽取重构到一个可复用的工具函数中，需要从文件的多个不同部分找到所需的正确片段。<br><img src="/2023/05/20/blog84/image-20231205180831963.png" alt="image-20231205180831963"><br><a name="s5Cwr"></a></p>
<h3 id="更好的类型推导"><a href="#更好的类型推导" class="headerlink" title="更好的类型推导"></a>更好的类型推导</h3><p>近几年来，越来越多的开发者开始使用 <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/">TypeScript</a> 书写更健壮可靠的代码，TypeScript 还提供了非常好的 IDE 开发支持。然而选项式 API 是在 2013 年被设计出来的，那时并没有把类型推导考虑进去，因此我们不得不做了一些<a target="_blank" rel="noopener" href="https://github.com/vuejs/core/blob/44b95276f5c086e1d88fa3c686a5f39eb5bb7821/packages/runtime-core/src/componentPublicInstance.ts#L132-L165">复杂到夸张的类型体操</a>才实现了对选项式 API 的类型推导。但尽管做了这么多的努力，选项式 API 的类型推导在处理 mixins 和依赖注入类型时依然不甚理想。<br>相比之下，组合式 API 主要利用基本的变量和函数，它们本身就是类型友好的。用组合式 API 重写的代码可以享受到完整的类型推导，不需要书写太多类型标注。大多数时候，用 TypeScript 书写的组合式 API 代码和用 JavaScript 写都差不太多！这也让许多纯 JavaScript 用户也能从 IDE 中享受到部分类型推导功能。<br><a name="FCOHG"></a></p>
<h3 id="更小的生产包体积"><a href="#更小的生产包体积" class="headerlink" title="更小的生产包体积"></a>更小的生产包体积</h3><p>搭配 script setup使用组合式 API 比等价情况下的选项式 API 更高效，对代码压缩也更友好。这是由于 script setup&gt; 形式书写的组件模板被编译为了一个内联函数，和 Script setup&gt; 中的代码位于同一作用域。不像选项式 API 需要依赖 this 上下文对象访问属性，被编译的模板可以直接访问 script setup&gt; 中定义的变量，无需从实例中代理。这对代码压缩更友好，因为本地变量的名字可以被压缩，但对象的属性名则不能。</p>
<p><a name="WDECv"></a></p>
<h2 id="升级vue2-7"><a href="#升级vue2-7" class="headerlink" title="升级vue2.7"></a>升级vue2.7</h2><p>安装、升级依赖：<br><img src="/2023/05/20/blog84/1698127606884-2025252a-5143-4f95-861c-be9c5d2312ae.png" alt="image.png"><br>深度选择器改写::v-deep、&#x2F;deep&#x2F;为:deep()<br><a name="DfQm5"></a></p>
<h2 id="vue2-7-vs-vue3-区别"><a href="#vue2-7-vs-vue3-区别" class="headerlink" title="vue2.7 vs vue3 区别"></a>vue2.7 vs vue3 区别</h2><p><img src="/2023/05/20/blog84/1698220931108-752f7412-fc63-4052-9669-7682266edb3c.png" alt="image.png"><br><a name="sbPdS"></a></p>
<h2 id="vue-2-7使用"><a href="#vue-2-7使用" class="headerlink" title="vue 2.7使用"></a>vue 2.7使用</h2><p><img src="/2023/05/20/blog84/1698127663753-4d504f4b-30cd-4d84-83aa-0bd570a64bb6.png" alt="image.png"><br><img src="/2023/05/20/blog84/1698127673648-22925b90-5ae2-425f-adc6-49ae0dfbeefa.png" alt="image.png"><br><img src="/2023/05/20/blog84/1698127683463-e2fe6b1c-0a04-494f-b9ad-ec0104394b2e.png" alt="image.png"><br><a name="aP84Q"></a></p>
<h2 id="引入typescript"><a href="#引入typescript" class="headerlink" title="引入typescript"></a>引入typescript</h2><p><a name="xQRZA"></a></p>
<h2 id="升级所需要事项"><a href="#升级所需要事项" class="headerlink" title="升级所需要事项"></a>升级所需要事项</h2><ol>
<li>检查你的vue-eslint 是否为 9+版本，否则在启动服务的时候会报错，接下来下载 typescript ts-loaderyarn add typescript ts-loader -D ， 如果在安装过程中出现问题，切换到淘宝源进行下载，</li>
</ol>
<p>(注意：<strong>一直tsconfig.json一直使用不了，导致找不到ts的module，最后发现是ts-loader的版本过高的原因。）</strong></p>
<ol start="2">
<li>下载成功后使用 npx tsc –init 接下来你的项目中会生成 tsconfig.json文件如下所示<img src="/2023/05/20/blog84/1698131803999-105e5777-3480-43b4-9b2e-dc1a70c7393b.webp"></li>
<li>此文件为 typescript的配置文件，如果你无法使用此命令行，并且报错的情况，建议配置一下npx，或者尝试使用 tsc –init来进行初始化操作。</li>
<li>tsconfig.json的配置如下 ts配置 所示。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ruby</span><br><span class="line">复制代码&#123;</span><br><span class="line">  // red squiggle line appears here</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    &quot;target&quot;: &quot;esnext&quot;,</span><br><span class="line">    &quot;module&quot;: &quot;esnext&quot;,</span><br><span class="line">    &quot;strict&quot;: true,</span><br><span class="line">    &quot;jsx&quot;: &quot;preserve&quot;,</span><br><span class="line">    &quot;importHelpers&quot;: true,</span><br><span class="line">    &quot;moduleResolution&quot;: &quot;node&quot;,</span><br><span class="line">    &quot;experimentalDecorators&quot;: true,</span><br><span class="line">    &quot;esModuleInterop&quot;: true,</span><br><span class="line">    &quot;allowSyntheticDefaultImports&quot;: true,</span><br><span class="line">    &quot;sourceMap&quot;: true,</span><br><span class="line">    &quot;baseUrl&quot;: &quot;src&quot;,</span><br><span class="line">    // &quot;types&quot;: [&quot;webpack-env&quot;],</span><br><span class="line">    &quot;paths&quot;: &#123;</span><br><span class="line">      &quot;@/*&quot;: [&quot;./*&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;lib&quot;: [&quot;esnext&quot;, &quot;dom&quot;, &quot;dom.iterable&quot;, &quot;scripthost&quot;]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;include&quot;: [</span><br><span class="line">    &quot;src/**/*.ts&quot;,</span><br><span class="line">    &quot;src/**/*.tsx&quot;,</span><br><span class="line">    &quot;src/**/*.vue&quot;,</span><br><span class="line">    &quot;tests/**/*.ts&quot;,</span><br><span class="line">    &quot;tests/**/*.tsx&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;exclude&quot;: [&quot;node_modules&quot;],</span><br><span class="line">  &quot;compileOnSave&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>紧接着进行配置你的 vue.config.json 配置 configureWebpack，我的是函数形式，如果你是对象形式可以自行修改</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">javascript</span><br><span class="line">复制代码config.module.rules.push(&#123;</span><br><span class="line">      test: /.tsx?$/,</span><br><span class="line">      loader: &#x27;ts-loader&#x27;,</span><br><span class="line">      exclude: /node_modules/,</span><br><span class="line">      options: &#123;</span><br><span class="line">        appendTsSuffixTo: [/.vue$/], // ts-loader</span><br><span class="line">        configFile: path.resolve(__dirname, &#x27;./tsconfig.json&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<ol>
<li>.eslintrc.js 配置</li>
</ol>
<p><img src="/2023/05/20/blog84/1698131803934-239a892b-15c2-4bed-b452-95940348f9a8.webp"></p>
<ol>
<li>在src文件夹下创建shims-vue.d.ts 文件，配置为</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typescript</span><br><span class="line">复制代码declare module &#x27;*.vue&#x27; &#123;</span><br><span class="line">  import Vue from &#x27;vue&#x27;;</span><br><span class="line">  export default Vue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>安装并配置：<br><img src="/2023/05/20/blog84/1698131890323-8b0c104e-f0f0-4ac1-90b5-320ec10cc642.png" alt="image.png"></p>
<p><a name="BZDBb"></a></p>
<h1 id="composion-API用法"><a href="#composion-API用法" class="headerlink" title="composion API用法"></a>composion API用法</h1><p><a name="sSwew"></a></p>
<h2 id="组合式-API-Composition-API"><a href="#组合式-API-Composition-API" class="headerlink" title="组合式 API (Composition API)"></a>组合式 API (Composition API)</h2><p>通过组合式 API，我们可以使用导入的 API 函数来描述组件逻辑。在单文件组件中，组合式 API 通常会与 script setup&gt;](<a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/sfc-script-setup.html">https://cn.vuejs.org/api/sfc-script-setup.html</a>) 搭配使用。这个 setup attribute 是一个标识，告诉 Vue 需要在编译时进行一些处理，让我们可以更简洁地使用组合式 API。比如，script setup&gt; 中的导入和顶层变量&#x2F;函数都能够在模板中直接使用。<br>script setup&gt; 中的顶层的导入、声明的变量和函数可在同一组件的模板中直接使用。你可以理解为模板是在同一作用域内声明的一个 JavaScript 函数——它自然可以访问与它一起声明的所有内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, onMounted &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">// 响应式状态</span><br><span class="line">const count = ref(0)</span><br><span class="line"></span><br><span class="line">// 用来修改状态、触发更新的函数</span><br><span class="line">function increment() &#123;</span><br><span class="line">  count.value++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 生命周期钩子</span><br><span class="line">onMounted(() =&gt; &#123;</span><br><span class="line">  console.log(`The initial count is $&#123;count.value&#125;.`)</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;increment&quot;&gt;Count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>注意vue2.7和vue3的差异，其他语法composition api是通用的。<br>可以去官网看语法。<br><a name="h8pL1"></a></p>
<h2 id="vue官方推荐使用sfc的方式构建应用"><a href="#vue官方推荐使用sfc的方式构建应用" class="headerlink" title="vue官方推荐使用sfc的方式构建应用"></a>vue官方推荐使用sfc的方式构建应用</h2><p>css的模块化引入，之前在sfc的方式，是通过给style标签加上scoped属性，实现样式的模块化。<br>而在jsx中，是无法使用scoped的用法，另外直接导入xxx.scss的方法会使得样式挂载在全局中，解决方案可以使用css module。<br><img src="/2023/05/20/blog84/1698646058743-01e6e0c6-5807-4260-95a7-d95dc946a589.png" alt="image.png"><br><a name="sgoAq"></a></p>
<h3 id="tsx-vs-sfc"><a href="#tsx-vs-sfc" class="headerlink" title="tsx vs sfc"></a>tsx vs sfc</h3><p><strong>优势</strong></p>
<ol>
<li>除了“标签语法”外，都是 JS 原生的语法，学习成本较小</li>
<li>同时意味着更灵活，可控性强，留给开发者全部的发挥空间</li>
<li>与 TS 完美结合</li>
<li><strong>可以随着 ES、TS 的迭代升级自然进化</strong>，能力与开发体验都会不断提升</li>
<li>相较于 template 的 props、attrs、emits、slots 等概念，JSX 只有 props 一个概念，心智负担较小</li>
</ol>
<p><strong>劣势</strong></p>
<ol>
<li>部分人对于在 JS 里混入 HTML 语法表示很抗拒，感觉违背了逻辑与表现分离的原则</li>
<li>灵活意味着代码质量与程序员的水平强相关，也就是不好保证代码质量的下限</li>
<li>相应的，一些优化点需要程序员自己控制，比如 React 中的 useCallback、useMemo，相信能彻底弄明白的人不是多数</li>
<li>没有 template（SFC） 提供的 style 处理能力，如 scoped、module、状态驱动等</li>
</ol>
<p><strong>其他研发者的意见：</strong><br>JSX vs. Vue Template(SFC) 如果使用 JSX，就要放弃一些 Vue Template 带来的特性，比如一些自带的性能优化、状态驱动的动态 CSS 等。需要像 React 一样手动去做这些处理，这也就意味着有可能会降低整体工程质量的下限，当然好处就是更加顺滑的 TS 体验。对于这些点的取舍，还要同学们根据实际情况自己判断。毕竟软件开发本质上，是一项寻求平衡的妥协的艺术。同样实现简单的父子组件通信：<br>1 tsx需要对emits和slots特殊处理，例如@click 在 TSX 中要变为 onClick，自定义 emit 也要由 @child-click 变为 onChildClick。<br>2 functional Component（即只有 props、emits、slots 传入的组件），可以完美的使用 TSX；<br>3 没有 props 和 emits 传入的组件（如本文的 Parent 组件），使用 TSX 还算可以接受，但是实际上组件内部没有太多的利用上 TS；<br>4 普通组件，尤其是带了 props 和 emits 的组件，用 TSX 形式实在是有点强人所难</p>
<p><strong>因此，为了兼顾vue2的大部分同事的使用习惯和vue的特点，还是选择使用sfc比较方便。</strong><br><strong>（或者先使用sfc的方式，熟悉composion api的用法。在后续考虑tsx，tsx比较接近react的写法)</strong></p>
<p><a name="fMeTO"></a></p>
<h2 id="setup-中使用-vuex、vue-router"><a href="#setup-中使用-vuex、vue-router" class="headerlink" title="setup 中使用 vuex、vue-router"></a>setup 中使用 vuex、vue-router</h2><p>由于项目版本 vuex、vue-router 均为 v3，组合式 API 中，我们需要使用一些新的函数来代替访问  this等方法，如：this.$store、this.$router、this.$route。<br>解决方案：也用到了 getCurrentInstance，通过它封装一些方法使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getCurrentInstance &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useStore</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; proxy &#125; = <span class="title function_">getCurrentInstance</span>()</span><br><span class="line">  <span class="keyword">const</span> store = proxy.<span class="property">$store</span></span><br><span class="line">  <span class="keyword">return</span> store</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useRoute</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; proxy &#125; = <span class="title function_">getCurrentInstance</span>()</span><br><span class="line">  <span class="keyword">const</span> route = proxy.<span class="property">$route</span></span><br><span class="line">  <span class="keyword">return</span> route</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useRouter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; proxy &#125; = <span class="title function_">getCurrentInstance</span>()</span><br><span class="line">  <span class="keyword">const</span> router = proxy.<span class="property">$router</span></span><br><span class="line">  <span class="keyword">return</span> router</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还有一些其他写法可以参考此 issue：<a href="https://link.juejin.cn/?target=https://github.com/vuejs/vue-router/issues/3760">github.com&#x2F;vuejs&#x2F;vue-r…</a><br>然而组合式 API 下 vuex 的mapState, mapGetters, mapActions  和  mapMutations  辅助函数依然是无法使用的。可以尝试vuex-composition-helpers这个库，帮助轻松使用 Vuex 和 Composition API。<br><strong>vue-router方案二</strong><br>使用 unplugin-vue-define-options<br>unplugin-vue-define-options <br>安装<br>npm i unplugin-vue-define-options -D</p>
<p>使用<br>vue.config.js中添加插件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">export</span> = &#123;</span><br><span class="line">  <span class="title function_">configureWebpack</span>(<span class="params">config</span>) &#123;</span><br><span class="line">    config.<span class="property">plugins</span>.<span class="title function_">push</span>(<span class="built_in">require</span>(<span class="string">&quot;unplugin-vue-define-options/webpack&quot;</span>)())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">defineOptions</span>(&#123;</span><br><span class="line">  <span class="title function_">beforeRouteEnter</span>(<span class="params">to, <span class="keyword">from</span>, next</span>) &#123;</span><br><span class="line">    <span class="comment">// do somethings...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>


<p><a name="xZqi2"></a></p>
<h2 id="补充：关于-getCurrentInstance"><a href="#补充：关于-getCurrentInstance" class="headerlink" title="补充：关于 getCurrentInstance"></a>补充：关于 getCurrentInstance</h2><p>注意：getCurrentInstance 作为访问内部组件实例的方法，官方是不鼓励在应用程序代码中使用的.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getCurrentInstance &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyComponent</span> = &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> internalInstance = <span class="title function_">getCurrentInstance</span>()</span><br><span class="line"></span><br><span class="line">    internalInstance.<span class="property">appContext</span>.<span class="property">config</span>.<span class="property">globalProperties</span> <span class="comment">// access to globalProperties</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>并且 getCurrentInstance 只在 setup 或生命周期钩子中工作:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyComponent</span> = &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> internalInstance = <span class="title function_">getCurrentInstance</span>() <span class="comment">// works</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> id = <span class="title function_">useComponentId</span>() <span class="comment">// works</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="title function_">getCurrentInstance</span>() <span class="comment">// doesn&#x27;t work</span></span><br><span class="line">      <span class="title function_">useComponentId</span>() <span class="comment">// doesn&#x27;t work</span></span><br><span class="line"></span><br><span class="line">      internalInstance <span class="comment">// works</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">getCurrentInstance</span>() <span class="comment">// works</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span></span><br><span class="line">      <span class="title function_">h</span>(</span><br><span class="line">        <span class="string">&#x27;button&#x27;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">onClick</span>: handleClick</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">`uid: <span class="subst">$&#123;id&#125;</span>`</span></span><br><span class="line">      )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// also works if called on a composable</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useComponentId</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">getCurrentInstance</span>().<span class="property">uid</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/vue/">vue</a><a class="post-meta__tags" href="/tags/typescript/">typescript</a><a class="post-meta__tags" href="/tags/composition/">composition</a><a class="post-meta__tags" href="/tags/sfc/">sfc</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/24/blog87/" title="vue2.7 | vue3 ts sfc代码编写"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">vue2.7 | vue3 ts sfc代码编写</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/25/blog83/" title="npm 发布小版本更新"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">npm 发布小版本更新</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/05/24/blog87/" title="vue2.7 | vue3 ts sfc代码编写"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-24</div><div class="title">vue2.7 | vue3 ts sfc代码编写</div></div></a></div><div><a href="/2019/11/20/blog18/" title="前端学习之JavaScript的框架"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-11-20</div><div class="title">前端学习之JavaScript的框架</div></div></a></div><div><a href="/2019/12/03/blog19/" title="前端框架Vue学习的心得记录（基础篇）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-03</div><div class="title">前端框架Vue学习的心得记录（基础篇）</div></div></a></div><div><a href="/2019/12/10/blog25/" title="前端框架Vue学习的心得记录（深入响应式原理）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-10</div><div class="title">前端框架Vue学习的心得记录（深入响应式原理）</div></div></a></div><div><a href="/2019/12/06/blog20/" title="前端框架Vue学习的心得记录（深入了解组件）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-06</div><div class="title">前端框架Vue学习的心得记录（深入了解组件）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/blog_wxk.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">伍新奎</div><div class="author-info__description">前端开发工程师</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">96</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">150</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">68</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xinkuiwu"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#vue2%E4%BD%BF%E7%94%A8typescript-composition-API-tsc-or-sfc"><span class="toc-number">1.</span> <span class="toc-text">vue2使用typescript | composition API + tsc or sfc</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E6%96%B9%E6%A1%88%EF%BC%9Avue-property-decorator-vue-class-component-vue-facing-decorator"><span class="toc-number">2.</span> <span class="toc-text">传统方案：vue-property-decorator | vue class component | vue-facing-decorator</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#vue-property-decorator%E6%96%B9%E6%A1%88%E7%BC%BA%E7%82%B9"><span class="toc-number">2.0.0.1.</span> <span class="toc-text">vue-property-decorator方案缺点</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tsx%E7%BB%84%E5%90%88%E6%96%B9%E6%A1%88%EF%BC%9AVue-Components-TypeScript"><span class="toc-number">3.</span> <span class="toc-text">tsx组合方案：Vue Components + TypeScript</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vuex-Store%E7%9A%84%E7%97%9B"><span class="toc-number">3.1.</span> <span class="toc-text">Vuex Store的痛</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tsx-composion-API"><span class="toc-number">4.</span> <span class="toc-text">tsx+composion API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BA%E4%B8%8E%E7%9B%AE%E7%9A%84"><span class="toc-number">4.1.</span> <span class="toc-text">动机与目的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E%E7%8E%B0%E6%9C%89%E7%9A%84-API-%E9%85%8D%E5%90%88"><span class="toc-number">4.2.</span> <span class="toc-text">与现有的 API 配合</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E9%80%89%E6%8B%A9-%EF%BC%9Avue2-7%E5%8D%87%E7%BA%A7-typescript%E6%94%AF%E6%8C%81"><span class="toc-number">5.</span> <span class="toc-text">[最终选择]：vue2.7升级+typescript支持</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%84%E5%90%88%E5%BC%8F-API%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">什么是组合式 API？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E7%BB%84%E5%90%88%E5%BC%8F-API%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">为什么要有组合式 API？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E5%A5%BD%E7%9A%84%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8"><span class="toc-number">5.2.1.</span> <span class="toc-text">更好的逻辑复用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E7%81%B5%E6%B4%BB%E7%9A%84%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87"><span class="toc-number">5.2.2.</span> <span class="toc-text">更灵活的代码组织</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-number">5.2.3.</span> <span class="toc-text">更好的类型推导</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E5%B0%8F%E7%9A%84%E7%94%9F%E4%BA%A7%E5%8C%85%E4%BD%93%E7%A7%AF"><span class="toc-number">5.2.4.</span> <span class="toc-text">更小的生产包体积</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%87%E7%BA%A7vue2-7"><span class="toc-number">5.3.</span> <span class="toc-text">升级vue2.7</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue2-7-vs-vue3-%E5%8C%BA%E5%88%AB"><span class="toc-number">5.4.</span> <span class="toc-text">vue2.7 vs vue3 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-2-7%E4%BD%BF%E7%94%A8"><span class="toc-number">5.5.</span> <span class="toc-text">vue 2.7使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E5%85%A5typescript"><span class="toc-number">5.6.</span> <span class="toc-text">引入typescript</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%87%E7%BA%A7%E6%89%80%E9%9C%80%E8%A6%81%E4%BA%8B%E9%A1%B9"><span class="toc-number">5.7.</span> <span class="toc-text">升级所需要事项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#composion-API%E7%94%A8%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">composion API用法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%BC%8F-API-Composition-API"><span class="toc-number">6.1.</span> <span class="toc-text">组合式 API (Composition API)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E5%AE%98%E6%96%B9%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8sfc%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8"><span class="toc-number">6.2.</span> <span class="toc-text">vue官方推荐使用sfc的方式构建应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tsx-vs-sfc"><span class="toc-number">6.2.1.</span> <span class="toc-text">tsx vs sfc</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setup-%E4%B8%AD%E4%BD%BF%E7%94%A8-vuex%E3%80%81vue-router"><span class="toc-number">6.3.</span> <span class="toc-text">setup 中使用 vuex、vue-router</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%EF%BC%9A%E5%85%B3%E4%BA%8E-getCurrentInstance"><span class="toc-number">6.4.</span> <span class="toc-text">补充：关于 getCurrentInstance</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/05/blog96/" title="nestjs学习-5种http数据传输方式">nestjs学习-5种http数据传输方式</a><time datetime="2023-12-05T12:02:00.000Z" title="Created 2023-12-05 20:02:00">2023-12-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/23/blog95/" title="nestjs学习-快速掌握 Nest CLI">nestjs学习-快速掌握 Nest CLI</a><time datetime="2023-11-23T08:02:00.000Z" title="Created 2023-11-23 16:02:00">2023-11-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/15/blog90/" title="前端工程化- webpack | 项目打包webpack优化">前端工程化- webpack | 项目打包webpack优化</a><time datetime="2023-11-15T03:02:00.000Z" title="Created 2023-11-15 11:02:00">2023-11-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/01/blog94/" title="单元测试-jest搭建和使用">单元测试-jest搭建和使用</a><time datetime="2023-11-01T06:02:00.000Z" title="Created 2023-11-01 14:02:00">2023-11-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/20/blog93/" title="nodejs-PM2搭建和使用">nodejs-PM2搭建和使用</a><time datetime="2023-10-20T03:02:00.000Z" title="Created 2023-10-20 11:02:00">2023-10-20</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2023 By 伍新奎</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://lib.baomitu.com/fancyapps-ui/5.0.24/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div></div></body></html>